# 1. 협력하는 객체들의 공동체

"객체지향이란 실세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임"

객체지향 프로그래밍이란 현실 속에 존재하는 사물을 최대한 유사하게 모방해 소프트웨어 내부로 옮겨오는 작업이기 때문에 그 결과물인 객체지향 소프트웨어는 실세계의 투영이며 객체란 현실 세계에 존재하는 사물에 대한 추상화



객체지향의 목표는 실세계를 모방하는 것이 아니다. 오히려 고객과 사용자를 만족시킬 수 있는 새로운 세계를 창조하는 것이다. 



객체를 스스로 생각하고 스스로 결정하는 현실 세계의 생명체에 비유하는 것은 상태와 행위를 '캡슐화(encapsulation)' 하는 소프트웨어 객체의 '자율성(autonomous)' 을 설명하는 데 효과적임. 현실 세계의 사람들이 암묵적인 약속과 명시적인 계약을 기반으로 협력하며 목표를 달성해 나가는 과정은 '메시지(message)' 를 주고받으며 공동의 목표를 달성하기 위해 '협력(collaboration)' 하는 객체들의 관계를 설명하는 데 적합함. 실세계의 사물을 기반으로 소프트웨어 객체를 식별하고 구현까지 이어간다는 개념은 '연결완전성(seamlessness)' 을 설명하는 데 적합함. 



소프트웨어 객체란 실세계 사물의 모방이라는 전통적인 관점

역할, 책임, 협력은 우리가 삶을 영위하기 위해 다른 사람과 접촉하는 모든 곳에 존재함. 



### 요청과 응답으로 구성된 협력

사람들은 스스로 해결하지 못하는 문제와 마주치면 문제 해결에 필요한 지식을 알고 있거나 서비스를 제공해줄 수 있는 사람에게 도움을 요청(`request`) 함. 

하나의 문제를 해결하기 위해 다수의 사람 혹은 역할이 필요하기 때문에 한 사람에 대한 요청이 또 다른 사람에 대한 요청을 유발하는 것이 일반적임. **요청은 연쇄적으로 발생함.**

요청을 받은 사람은 주어진 책임을 다하면서 필요한 지식이나 서비스를 제공함. 다른 사람의 요청에 응답(response)함. 응답도 요청의 방향과 반대 방향으로 연쇄적으로 전달됨. 

요청과 응답을 통해 다른 사람과 협력(`collaboration`)할 수 있는 능력은 거대하고 복잡한 문제를 해결할 수 있는 공동체를 형성할 수 있게 만듦. 



### 역할과 책임

사람들은 다른 사람과 협력하는 과정 속에서 특정한 역할(role)을 부여받음. 역할은 어떤 협력에 참여하는 특정한 사람이 협력 안에서 차지하는 책임이나 임무를 의미함. 

특정한 역할은 특정한 책임을 암시함. 

협력에 참여하며 특정한 역할을 수행하는 사람들은 역할에 적합한 책임을 수행하게 됨. 



* 여러 사람이 동일한 역할을 수행할 수 있음.
* 역할을 대체 가능성을 의미함. 
* 책임을 수행하는 방법은 자율적으로 선택할 수 있음.
  * 요청을 처리할 방법을 자유롭게 
  * 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력 : 다형성(`polymorphism`)
* 한 사람이 동시에 여러 역할을 수행할 수 있음.



### 역할, 책임, 협력

특정한 목표를 이루기 위해 서로 협력함. 

협력의 핵심은 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다는 것

시스템은 역할과 책임을 수행하는 객체로 분할되고 시스템의 기능은 객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현됨.

적절한 객체에게 적절한 책임을 할당하는 것에서 시작됨. 

역할은 관련성 높은 책임의 집합

* 여러 객체가 동일한 역할을 수행할 수 있음
* 역할은 대체 가능성을 의미함
* 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있음
* 하나의 객체가 동시에 여러 역할을 수행할 수 있음.

역할은 유연하고 재사용 가능한 협력 관계를 구축하는 데 중요한 설계 요소

대체 가능한 역할과 책임은 객체지향 패러다임의 중요한 기반을 제공하는 다형성과도 깊이 연관돼있음.



### 협력 속에 사는 객체

객체지향 애플리케이션의 윤곽을 결정하는 것은 역할, 책임, 협력이지만 실제로 협력에 참여하는 주체는 객체다.

객체는 애플리케이션의 기능을 구현하기 위해 존재함

1. 객체는 충분히 협력적이어야 함. 

* 외부의 도움을 무시한 채 모든 것을 스스로 처리하려고 하는 전지전능한 객체 는 내부적은 복잡도에 의해 자멸하고 만다. 

> 단일 책임 

2. 객체가 충분히 자율적이어야 함. 자기 스스로의 원칙에 따라 어떤 일을 하거나 자기 스스로를 통제하여 절제하는 것을 의미함. 

객체 공동체에 속한 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만 스스로의 결정과 판단에 따라 행동하는 자율적인 존재다. 



### 상태와 행동을 함께 지닌 자율적인 객체

객체를 상태(state)와 행동(behavior)을 함께 지닌 실체

객체가 협력에 참여하기 위해 어떤 행동을 해야 한다면 그 행동을 하는 데 필요한 상태도 함께 지니고 있어야 한다는 것 



객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 나옴. 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야 하며 객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통해야 함. 객체는 다른 객체가 '무엇(what)' 을 수행하는지는 알 수 있지만 '어떻게(how)' 수행하는지에 대해서는 알 수 없다. 



=> 객체는 상태와 행위를 하나의 단위로 묶는 자율적인 존재



과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분함. 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 함께 묶어 놓음으로써 객체의 자율성을 보장함. 자율적인 객체로 구성된 공동체는 유지보수가 쉽고 재사용이 용이한 시스템을 구축할 수 있는 가능성을 제시함. 



### 협력과 메시지

객체지향에서 협력은 메시지를 전송하는 객체와 메시지를 수신하는 객체 사이의 관계로 구성됨. 

* 송신자(`sender`) : 메시지를 전송하는 객체
* 수신자(`receiver`) : 메시지를 수신하는 객체



### 메서드와 자율성

* 메서드(method) : 객체가 수신된 메시지를 처리하는 방법
  * 객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 함수 또는 프로시저를 통해 구현됨. 
  * 어떤 객체에게 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행됨. 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 점은 절차 지향 언어와 구분되는 특징임. 

메시지와 메서드의 분리는 객체의 협력에 참여하는 객체들 간의 자율성을 증진시킴.

외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘. 캡슐화(`encapsulation`)



### 객체지향의 본질

* 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법
* 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체
* 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력함. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합
* 객체는 다른 객체와 협력하기 위해 메시지를 전송하고 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택함. 



# 2. 이상한 나라의 객체





# 3. 타입과 추상화

> 지하철 노선도. 직관적으로 표현함. 중요한 정보를 파악하기 쉽게. 목적에 집중함.

## 추상화를 통한 복잡성 극복 

* 목적에 맞게 현실을 분해하고 단순화함.
* 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복함. 
* 추상화의 수준, 이익, 가치는 목적에 의존적임. 



### 추상화

* 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법

1. 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만듦.
2. 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거함으로써 단순하게 만듦. 

=> 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것



## 객체지향과 추상화

> ''기껏해야 트럼프에 불과해'



### 그룹으로 나누어 단순화하기 

* 객체 : 명확한 경계를 가지고 서로 구별할 수 있는 구체적인 사람이나 사물



### 개념(`concept`)

* 공통점을 기반으로 객체를 분류할 수 있는 일종의 체 
* 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념
* 개념을 이용해 객체를 여러 그룹을 분류(`classification`)할 수 있음.

=> '객체'란 특정한 개념을 적용할 수 있는 구체적인 사물. 개념이 객체에 적용됐을 대 객체를 개념의 인스턴스(`instance`)라고 함. 



### 개념의 세가지 관점

* 개념은 특정한 객체가 어떤 그룹에 속할 것인지를 결정함. 

* 심볼(`symbol`) : 개념을 가리키는 간략한 이름이나 명칭

> 트럼프

* 내연(`intension`) : 개념의 완전한 정의. 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있음.

> 몸이 납작하고 두 손과 두 발은 네모 귀퉁이에 달려 있는 등장인물

* 외연(`extension`) : 개념에 속하는 모든 객체의 집합(`set`)

> 정원사, 병사, 신하, 왕자와 공주, 왕과 왕비



### 객체를 분류하기 위한 틀 

* **분류** 란 : 특정한 객체를 특정한 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업



### 분류는 추상화를 위한 도구다

* 개념은 객체들의 복잡성을 극복하기 위한 추상화 도구



## 타입

### 타입은 개념이다

* 공통점을 기반으로 객체들을 묶기 위한 틀



### 데이터 타입

* 데이터를 목적에 따라 분류하기 위해
* 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하기 위해
* 데이터가 잘못 사용되는 것을 방지
* 메모리 안에 저장된 데이터 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터



### 객체와 타입

* 객체지향 프로그램을 작성할 때 객체를 일종의 데이터처럼 사용함.
* 객체는 행위에 따라 변할 수 있는 상태를 가지고 있음. 

=> 객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심 

1. 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동임. 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있음.
2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰짐. 



### 행동이 우선이다

* 동일한 책임을 수행하는 일련의 객체는 동일한 타입에 속함. 
* 객체의 타입을 결정하는 것은 객체의 행동뿐임. 
* 다형성 : 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력
* 캡슐화 : 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춤.
* 책임-주도 설계(`Responsibility-Driven Design`) 은 데이터를 먼저 생각하는 데이터-주도 설계 방법의 단점을 개선하기 위해 고안됨. 



## 타입의 계층

> 트럼프 > 트럼프 인간

### 일반화(`generalization`)/특수화(`specialization`) 관계

* 특수한 타입은 일반적인 타입이 가진 모든 타입을 포함하지만 자신만의 행동을 추가함. 



### 슈퍼타입(`Supertype`)과 서브타입(`Subtype`)

* 어떤 타입이 다른 타입의 서브타입이려면 다른 타입을 대체할 수 있어야 함. 

> 리스코프 치환

* 서브타입은 슈퍼타입과 중복된 행위를 생략할 수 있음. 슈퍼타입의 행동은 서브타입에게 자동으로 상속됨. 



### 일반화는 추상화를 위한 도구다 

* 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거시켜 단순하게 만드는 것
* 차이점을 배제하고 공통점만을 강조함으로써 공통 타입으로 분류함.
* 불필요한 특성을 배제하고 포괄적인 의미로 일반화함. 



## 정적 모델

### 그래서 결국 타입은 추상화다

* 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있음.
* 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있음. 



### 동적 모델과 정적 모델

* 동적 모델(`dynamic model`) : 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것. (스냅샷, 객체 다이어그램)
* 정적 모델(`static diagram`) : 객체가 가질 수 있는 모든 상태와 모든 행동을 정적인 모습으로 표현하는 것. (타입 모델)



### 클래스

* 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현됨.
* 타입을 구현하는 가장 보편적인 방법. 
* 객체를 분류하는 기준은 타입. 타입을 나누는 기준은 객체가 수행하는 행동. 



=> 동적으로 변하는 객체의 '상태'와 상태를 변경하는 '행위'



> # 1 ~ 3장 느낀점
>
> 객체지향 프로그래밍에 대해서 친근한 예시로 설명이 되어있어서 이해하기 쉬웠다. 
>
> 다소 같은 이야기가 반복되는 느낌은 있었으나, 객체지향 프로그래밍에 대해서 확실하게 알게 될 것 같아 좋았다. 
>
> 특히 객체를 만들 때, 객체가 할 행동을 중심으로 생성해야 된다는 것을 크게 깨달았다. 
>
> 스위프트를 다중 패러다임 프로그래밍 언어라고 흔히 말하는데, 지금까지 클래스를 이용한 상속을 잘 구현한 적이 없는 것 같다. 
>
> 책 설명의 자바스크립트처럼 나도 모르게 프로토콜 지향 프로그래밍에 더 익숙했던 것인가 생각했다.
>
> 그것이 이분적인 개념은 아니지만 1장을 읽으면서 클래스와 프로토콜, 프로토콜 지향 프로그래밍은 어떤 것인가, 클래스 상속 활용에 대해 더 알고 싶어졌다. 



# 4. 역할, 책임, 협력

### * 협력 : 요청과 응답의 연쇄적인 흐름

### * 객체지향 시스템 : 동일한 목적을 달성하기 위해 역할과 책임을 수행하며 협력하는 자율적인 객체들의 공동체

### * 책임 : 어떤 객체가 어떤 요청에 대해 대답(외부에 제공할 수 있는 정보)해 줄 수 있거나 적절한 행동(외부에 제공할 수 있는 서비스)을 할 의무가 있음

* 객체의 공용 인터페이스(`public interface`)를 구성함. 

* 객체가 무엇을 알고 있는가(`knowing`) / 무엇을 할 수 있는가(`doing`)
  * 아는 것 (`knowing`)
    * 개인 정보, 관련된 객체, 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
  * 하는 것(`doing`)
    * 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    * 다른 객체의 행동을 시작시키는 것
    * 다른 객체의 활동을 제어하고 조절하는 것

### * 역할 : 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있음

* 역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야 함. 



## 올바른 객체를 설계하기 위해서

1. 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정 => 책임 : 객체가 외부에 제공하게 될 행동
2. 행동을 수행하는 데 필요한 데이터 고민
3. 클래스의 구현 방법 결정



## 객체지향 설계 기법

### 1. 책임-주도 설계(`Responsibility-Driven Design`) 

* 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션을 설계함

  > * 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악
  > * 시스템 책임을 더 작은 책임으로 분할
  > * 분할된 책임을 수행할 수 있는 적절할 객체, 역할을 찾아 책임을 할당
  > * 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 객체, 역할을 찾음
  > * 해당 객체, 역할에게 책임을 할당함으로써 두 객체가 협력하게 함

### 2. 디자인 패턴(`Design Pattern`)

* 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿의 모음
* 이미 식별해 놓은 공통으로 사용할 수 있는 역할, 책임, 협력의 모음

### 3. 테스트-주도 개발(`Test-Driven Development`)

* 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식
* 핵심은 테스트 작성이 아님. 식별된 역할, 책임, 협력이 적합한지를 피드백 받는 것임. 



# 5. 책임과 메시지

### * 자율적인 객체 : 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체

* 객체가 자율적이기 위해서는 객체에게 할당되는 책임의 수준도 자율적이어야 함.

### * 자율적인 책임 : 객체가 '어떻게(`how`)' 해야 하는가가 아니라 '무엇(`what`)'을 해야 하는가를 설명함

* 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 함. 

### * 메시지 : 객체가 자신에게 할당된 책임을 수행하도록 만드는 외부에서 전달된 요청

### 다른 객체의 행동을 수행하도록 접근하려고 전달하는 요청

148



# 6. 객체 지도

### * 구조 : 사용자나 이해관계자들이 도메인(`domain`)에 관해 생각하는 개념과 개념들 간의 관계로 표현 

* 도메인 모델링 : 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태 
  * 멘탈 모델(`Mental Model`) : 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형
  * 장점 : 비즈니스 개념과 정책을 반영하는 안정적인 구조를 제공

### * 기능 : 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현 

* 유스케이스 모델링 : 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리
  * 내부 설계와 관련된 정보를 포함하지 않음



=> **안정적인 도메인 모델을 기반으로 시스템의 기능을 구현하여 기능이 변경되더라도 전체적인 구조가 흔들리지 않도록 해야 함.**

* 기능을 중심으로 설계하면 기능은 자주 변경되기 때문에 유지보수 비용이 많이 발생하게 됨.

### * 연결 완전성 : 도메인을 모델링하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일함



# 7. 함께 모으기







> # 4~7장 느낀점
>
> TDD의 목적에 대해 다시 깨달을 수 있어서 좋았다. 테스트도 설계를 잘하기 위한 도구일 뿐..! 
>
> SOLID 원칙에 대해 더 이해할 수 있게 되어서 의미 있는 독서였다고 생각한다. 
>
> 객체지향 프로그래밍은 책임과 역할에 따라 분리해놓은 객체들이 서로 협력하도록 만드는 패러다임이다. 



[객체지향의 사실과 오해 - 조영호](http://www.yes24.com/Product/Goods/18249021)