# 스위프트 메모리 구조

## 참조 타입 객체(`Reference Type Objects`)

* 간단한 클래스는 참조 타입
* 단일 클래스 객체는 여러 변수에 의해 참조되고 조작될 수 있음
* Heap은 동적할당에 사용되는 메모리의 한 부분
  * 앱을 실행할 때 즉시 새로운 참조 타입 객체를 만들어야 하는 경우 힙에 공간을 요청해야 함
  * 데이터를 손상시키지 않고 동시에 여러 개의 스레드를 처리할 수 있어야 하므로 동일한 메모리 블록을 두 번 할당하는 것을 방지하고, 병렬 할당 호출을 처리하는 메커니즘이 필요함
* 클래스의 실제 값을 초기화하는 것 이외에도 일부 메타데이터 값이 초기화되고 있음



### ARC(`Automatic Reference Counting`)

* 객체가 사용되고 있는지를 추적하기 위한 장치
* 어떤 변수에서도 참조하지 않는 객체는 안전하게 제거될 수 있고, 그 메모리는 반환될 수 있음
* 객체 생성, 공유 시마다 카운터를 업데이트 해야하는 부하가 있음



## 값 타입 객체(`Value Type Objects`)

* enum, struct는 값 타입
* Stack
  * 데이터가 쌓이고 새로운 데이터를 추가하면 데이터가 맨 위에 추가됨
  * 데이터의 제거 또한 메모리 공간의 맨위로 제한됨
  * 장점 : 메모리 할당 및 해제는 단순한 증가 또는 감소 작업으로, 매우 빠름
  * 힙이 제공할 수 있는 동적 할당과 양립할 수 없음



## Array

* 동적 타입, 런타임에 크기를 바꿀 수 있음
* 따라서 참조 유형처럼 취급됨 (Heap에 할당)
* 어레이 할당에 드는 비용이 크기를 조정하는 것보다 큼
* 어레이의 크기를 정확히 안다면 `reserveCapacity(_:)`를 사용해서 할당 비용을 더욱 줄일 수 있음



## 참조 타입을 사용하는 경우

* 일반적으로 여러 부분에서 변형 상태를 공유할 수 있어야 함
* 새로운 메모리의 할당을 피해야 하는 상황
* 외부 프레임워크의 일부를 subclass 해야하는 상황



## 값 타입을 사용하는 경우

* 참조 타입을 사용하는 경우 의외
* 버그의 추적을 더 쉽게 함
* 할당 및 관리 방식이 성능을 향상시킴



[참고](https://kor45cw.tistory.com/251)











