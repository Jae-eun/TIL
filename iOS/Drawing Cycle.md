# Drawing Cycle

UIView 클래스는 컨텐츠를 표시할 때, on-demand 드로잉 모델을 사용합니다.

View가 처음 화면에 나타나면, **시스템은 컨텐츠를 그려달라고 요청**합니다.

시스템은 이 컨텐츠의 **스냅샷을 캡쳐**하고, 해당 스냅샷을 View의 시각적 표현으로 사용합니다.

View의 내용을 변경하지 않으면 View의 드로잉 코드를 다시 호출할 수 없습니다.

스냅샷 이미지는 View와 관련된 대부분의 작업에 다시 사용됩니다. 

컨텐츠를 변경하면 View가 변경되었음을 시스템에 알립니다. 그런 다음 View는 View를 그리고 새 결과의 스냅샷을 캡쳐하는 프로세스를 반복합니다.

View의 내용이 변경되면 해당 변경사항을 직접 다시 그리지는 않습니다. 

대신 setNeedsDisplay 메소드를 사용하여 View를 무효화합니다.

이 메소드는 View의 내용이 변경되어 다음 기회에 다시 그려질 필요가 있음을 시스템에 알립니다. 

시스템은 드로잉 작업을 시작하기 전에 현재 실행루프가 끝날 때까지 대기합니다.

대기함으로써 여러 View를 무효화하고, 계층구조에서 추가 또는 제거하고, View를 숨기고, View의 크기를 조정하고 View의 위치를 한번에 재조정할 수 있습니다.

변경사항은 모두 동시에 반영됩니다.

View를 처음 표시하거나 View의 일부를 다시 그려야 하는 경우, View의 draw 메소드를 호출해서 View에 컨텐츠를 그려달라고 요청합니다.



- View 업데이트를 자동으로 실행되도록 할 수 있는 작업

**1. View를 부분적으로 가리고 있던 다른 View 이동 또는 제거**

**2. hidden 프로퍼티를 No로 설정하여, 이전에 숨겨진 View를 다시 볼 수 있게 만들기**

**3. View를 화면 밖으로 스크롤한 다음, 화면으로 다시 이동하기**

**4. View의 setNeedsDisplay 또는 setNeedsDisplayInRect: 메소드를 명시적으로 호출하기**



# draw(_ rect: CGRect)

**전달된 사각형(파라미터로 받은 CGRect타입) 내에서 receiver의 이미지를 그립니다.**

매개변수인 rect : 업데이트해야 하는 View의 bounds 일부

처음 View를 그릴 때, 이 사각형은 일반적으로 View의 전체 범위임. 이후의 그리기 작업의 사각형은 View의 일부만 지정할 수 있음.

draw 메소드의 디폴트 구현에는 아무 기능이 없음.

Core Graphics 및 UIKit와 같은 기술을 사용하여 뷰의 내용을 그리는 하위 클래스에서 이 메서드를 재정의하고 드로잉 코드를 구현해야 함.

(View의 배경색만 표시하거나, View가 기본 레이어 객체를 사용하여 직접 컨텐츠를 설정하는 경우에는 draw 메소드를 재정의 할 필요가 없음)



??

UIView를 직접 하위클래스로 만들면, 이 메소드를 구현할 때 super를 호출할 필요가 없습니다. 그러나 다른 View 클래스를 하위 클래스화하는 경우, 구현의 어느 시점에서 super를 호출해야 합니다.

draw 메소드는 View가 처음 표시될 때, 또는 View의 보이는 부분을 무효화하는 이벤트가 발생할 때 호출됩니다.



**직접 draw 메소드를 호출하면 안됩니다!** View의 일부분을 무효화하고 해당 부분을 다시 그려지게 하려면 setNeedsDisplay() 또는 setNeedsDisplay(_ :) 메서드를 호출해야 합니다.



#  setNeedsDisplay()

UIView의 하위 메소드

View의 실제 컨텐츠가 변경될 때, **다음 드로잉 사이클동안 View를 다시 그려야 함을 시스템에 알리는 것**

View를 업데이트하기 위해 다음 드로잉 사이클때까지 기다리기 때문에, 여러 View에서 이 메소드를 호출하여 동시에 업데이트 할 수 있습니다.

이 메소드는 요청을 기록하고, **즉시 리턴**합니다.



View가 CAEAGLLayer(deprecated) 객체 뒤에 있는 경우, setNeedsDisplay() 메소드는 아무 효과가 없습니다. 이 메소드는 내용을 렌더링하기 위해 native drawing technologies(UIKit, Core Graphics 등)을 사용하는 View에서만 사용할 수 있습니다.



이 메소드를 사용하면, **View의 내용이나 모양이 변경된 경우에만 View를 다시 그립니다.** 단순히 View의 기하(geometry)(크기,위치..?)를 변경하면, View는 일반적으로 다시 그려지지 않습니다. 대신 기존 내용은 View의 contentMode 속성 값을 기반으로 조정됩니다. 기존 내용을 다시 표시하면, 변경되지 않은 내용을 다시 그리지 않아도 되므로 성능이 향상됩니다. 



**View의 프로퍼티가 수정될 때마다 내부적으로 setNeedsDisplay()가 자동으로 실행되고, 영향을 받는 영역이 다시 그려짐**



**자신만의 View를 만들고 자체 draw 메소드를 구현한 후, 무언가가 변경되어 명시적으로 업데이트하게 할 때 호출해야 함**!



# setNeedsLayout()

UIView의 인스턴스 메소드

**receiver의 현재 레이아웃을 무효화하고, 다음 업데이트 주기 동안 레이아웃 업데이트를 자동으로 실행합니다.**



View의 하위 View 레이아웃을 조정하려면, App의 main 스레드에서 이 메소드를 호출하면 됩니다. 이 메소드는 요청을 기록하고 즉시 리턴합니다. 즉시 업데이트 하지 않고, 다음 업데이트 주기를 기다리기 때문에 View를 업데이트 하기 전에 여러 View의 레이아웃을 무효화하는데 사용할 수 있습니다.



**비동기 작업**

: 메소드가 완료되면 즉시 반환되는데, 레이아웃과 다시 그리는 작업이 실제로 발생하기 전이며, 업데이트 주기가 언제일지 모르는 상태이므로.



# layoutSubviews()

UIView의 인스턴스 메소드

**Subview들을 배치합니다**.



기본 구현은 하위 View의 크기와 위치를 결정하기 위해 설정한 제약조건(constraint)를 사용합니다. SubClass는 Subview의 더 정확한 레이아웃 적용을 위해 필요에 따라 이 메소드를 오버라이드 할 수 있습니다.

하위 뷰의 자동 크기 조정 및 제약 조건 기반 동작이 원하는 동작을 제공하지 않는 경우에만 이 메소드를 제정의해야 합니다. 

이 메소드를 구현하여 하위 뷰의 프레임 사각형을 직접 설정할 수 있습니다.

**이 메소드를 직접 호출하면 안됩니다!** 강제로 레이아웃을 업데이트 하려면 다음 드로잉 업데이트 전에 setNeedsLayout() 메소드를 호출하십시오. 뷰의 레이아웃을 즉시 업데이트 하려면 layoutIfNeeded() 메소드를 호출하세요.



# layoutIfNeeded()

**View의 레이아웃을 즉시 업데이트합니다.**



autoLayout을 사용할 때, 레이아웃 엔진은 필요에 따라 View의 위치를 업데이트하여 제약 조건의 변경사항을 충족시킵니다. 이 메소드는 메세지를 루트 뷰로 수신하는 뷰를 사용하여 루트에서 시작하는 뷰 하위 트리를 배치합니다.

보류 중인 레이아웃 갱신이 없는 경우, 레이아웃을 변경하거나 레이아웃 관련 콜백을 호출하지 않고 종료합니다.

**동기 작업**

: 업데이트 주기를 기다리지 않고 즉시 완료함. 호출이 완료되면, 메소드 호출 이전에 기록된 모든 변경 내용을 기반으로 레이아웃이 이미 조정되고 그려짐.







