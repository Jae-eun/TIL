# 디자인 패턴

> 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 수 있는 훌륭한 해결책

### 패턴

* 각각 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용 소프트웨어 시스템들을 개발할 때도 서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에도 공통점이 있음
* 공통의 언어를 만들어주며 팀원 사이의 의사 소통을 원활하게 해주는 역할을 함



## 디자인 패턴 구조

### 콘텍스트(`context`)

* 문제가 발생하는 상황을 기술함. 즉, 패턴이 적용될 수 있는 상황을 나타냄
* 경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 함

### 문제(`problem`)

* 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술함
* 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 함

### 해결(`solution`)

* 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술함
* 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿임



## GoF(`Gang of Fout`) 디자인 패턴

### 생성(`Creational`) 패턴

* 추상 팩토리(`Abstract Factory`) : 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
* 빌더(`Builder`) : 생성과 표기를 분리해 복잡한 객체를 생성함
* 팩토리 메서드(`Factory Method`) : 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴
* 프로토타입(`Prototype`) : 기존 객체를 복제함으로써 객체를 생성함
* 싱글턴(`Singleton`) : 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴

### 구조(`Structual`) 패턴

* 어댑터(`Adapter`) : 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움
* 브리지(`Bridge`) : 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있음
* 컴퍼지트(`Composite`) : 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
* 데커레이터(`Decorator`) : 객체의 결합을 통해 기능을 동적으로  유연하게 확장할 수 있게 해주는 패턴
* 퍼사드(`Facade`) : 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스를 제공함
* 플라이웨이트(`Flyweight`) : 다수의 유사한 객체를 생성, 조작하는 비용을 절감할 수 있음
* 프록시(`Proxy`) : 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역을 제공함

### 행위(`Behavioral`) 패턴

* 책임 연쇄(`Chain of Responsibility`) : 책임들이 연결되어 있어 내가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 구조
* 명령(`Command`) : 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
* 해석자(`Interpreter`) : 문법 규칙을 클래스화한 구조를 갖는 SQL 언어나 통신 프로토콜 같은 것을 개발할 때 사용
* 반복자(`Iterator`) : 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근할 수 있도록 메서드를 이용해 자료구조를 활용할 수 있도록 해줌
* 중재자(`Mediator`) : 클래스 간의 복잡한 상호 작용을 캡슐화하여 한 클래스에 위임해서 처리하는 디자인 패턴
* 메멘토(`Memento`) : 클래스 설계 관점에서 객체의 정보를 저장
* 감시자(`Observer`) : 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴
* 상태(`State`) : 객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴
* 전략(`Strategy`) : 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
* 템플릿 메서드(`Template Method`) : 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
* 방문자(`Visitor`) : 각 클래스의 데이터 구조로부터 처리 기능을 분리하여 별도의 visitor 클래스로 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 것



1. 생성 패턴
   * 객체 생성에 관련된 패턴
   * 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공함
2. 구조 패턴
   * 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
   * 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴
3. 행위 패턴
   * 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
   * 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그러면서 객체 사이의 결합도를 최소화하는 것에 중점을 둠



[참고1](https://gmlwjd9405.github.io/2018/07/06/design-pattern.html)

[참고2](https://gone-sw.tistory.com/4)