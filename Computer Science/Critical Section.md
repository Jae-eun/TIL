# Critical Section

**임계영역, 임계구역**

: 멀티 프로세스의 각 프로세스가 데이터를 공유하며 수행될 때 동시 접근 가능한 프로그램 코드 영역

: 이 공유 자원에 대한 독점 사용을 제공하는 역할



1. 동일 프로세스 내의 스레드 사이에서만 동기화 가능.
2. 유저 모드 동기화 객체이므로 다른 커널 모드 객체(Mutex, Semaphore)에 비해 가볍고 빠름.
3. 먼저 접근한 스레드는 EnterCriticalSection을 통해 락을 획득하고, 그 이후 접근하는 스레드는 대기시킴. 할 일을 마치면 LeaveCriticalSection으로 락을 해제 후, 다른 스레드가 접근할 수 있게 됨.
4. 대기 중인 스레드는 다른 스레드에게 CPU 점유를 넘겨야 하므로 컨텍스트 스위칭이 발생하지만 이후 대기시간 동안은 CPU 자원을 점유하지 않음.

** Spin Lock (스핀락)

: 락을 먼저 선점한 스레드가 있을 때, 그 뒤의 스레드는 락이 풀릴 때까지 대기하게 됨. 이 때 작업 스레드 교환에 따른 컨텍스트 스위칭 비용이 따르게 됨. 또, 락이 해제되어 대기 중이던 스레드가 깨어나면 다시 한 번 컨텍스트 스위칭이 일어남. 선점한 스레드를 기다리는 시간이 길지 않다면 이런 스위칭 비용은 자원의 낭비를 초래하므로 이런 단점을 해소하기 위해 스핀락을 사용함.

**임계영역에 진입하지 못할 때 대기 모드로 들어가는 대신, 진입 가능할 때까지 무한 루프를 돌며 Busy-Wating 상태로 만들어 락을 얻을 수 있을 때까지 재시도하는 방식으로 구현된 락** 

(Busy-Waiting : 스레드가 활성 상태이지만 실제로는 아무 일도 하지 않는 것)

: 컨텍스트 스위칭에 소요되는 시간보다 짧은 시간 내에 락을 얻을 수 있다면 효과적임. 하지만 루프를 도는 시간이 길어지게 되면 오히려 더 많은 자원을 낭비하게 될 수 도 있음. 무한 루프 상태이기 때문에 CPU 점유율이 상당히 높아지는 결과를 초래할 수 있음. 따라서 무한 루프를 도는 대신 sleep 상태로 대기했다가 다시 시도하는 방식으로 사용하기도 함.





참고 : http://blog.naver.com/PostView.nhn?blogId=itperson&logNo=220933533752&parentCategoryNo=&categoryNo=50&viewDate=&isShowPopularPosts=false&from=postView