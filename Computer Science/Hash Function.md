# 해시 함수

* 목적과 특징

  해시 : 데이터 변조를 막기 위한 조치로 만들어진 기법

  * 입력의 크기와 상관 없이 일정한 길이의 출력 값을 출력함
  * 한 글자라도 변조가 발생하면 해시 값 전체가 변화함
  * 중간에 데이터 변조가 발생하였는지 여부를 확인할 수 있음(SHA 알고리즘)
  * 평균 시간 복잡도가 O(1)로 매우 빠름
  * 배열 구조에 각 아이템의 Hash 함수에 의해 만들어진 Hash 값을 인덱스로 저장되는 자료구조
  * 각 아이템의 Hash 값을 통해 해당 값에 바로 접근할 수 자료구조
  * Key-Value 한 쌍으로 구성됨

* 장점

  * 값을 거의 바로 찾을 수 있음

* 해쉬 충돌

   : 배열에 중복이 많이 발생하면 저장과 반환에 문제가 발생함.

   : 사용자가 설정한 key가 해시 함수에 의해 배열의 인덱스로 변환되었을 때, 이 인덱스로 배열에 접근했는데 어떤 값이 이미 그 자리를 차지하는 경우

  : 서로 다른 키 값이 해시 함수를 통해 같은 해시 값으로 나오는 상황

* 해결 방법

  : 해시 함수를 잘 짜야한다.

  1) Open addressing : 해시 값과 실제 저장된 위치가 다를 수 있다. 즉, 충돌이 일어나면 다른 인덱스에 저장하도록 조정한다. 

  * 선형 탐사 : 인덱스에 이미 값이 있으면 다음 칸이 비어 있는지 검사하여 넣는다.
  * 제곱 탐사 
  * 이중해시 : 해시 함수를 2개 두고 평소에는 하나만 쓰다가 충돌시 2번째 함수를 써서 새로운 인덱스로 조정하는 방법

  2) Close addressing : 해시 값과 실제 저장된 위치는 다를 수 없다. 충돌이 일어나도 해당 위치에 저장한다. 기존 값을 버리거나 덮어씌우지는 않는다.

  * 버켓 : 배열의 한 요소가 다시 배열이다. 즉, 1차원 배열이 아닌 2차원 배열이다. 충돌이 일어나면 다른 위치로 재조정하지 않고 해당 위치에 배열로 쌓는다.
  * 체이닝 : 충돌된 값들을 연결리스트로 연결한다.

  : 충돌이 일어났을 때 특별한 연산을 통해 비어 있는 다른 인덱스를 찾는 방법과 배열 안에 배열 혹은 연결 리스트로 계속 붙여나가는 방법

  

  # 암호화 vs 해시함수

  * 차이점 : 해시는 역함수가 없어서 복호화를 통하여 평문을 확인할 수 있는 암호화 도구들과 달리 해시 함수는 복호화를 할 수 없다.

* Hash : 단방향 암호화 기법

  : 평문을 암호화된 텍스트로 만들어주는 기능

* Encryption : 양방향 암호화 기법

  : 평문을 암호화된 텍스트로 만들어주는 기능 + 암호화된 문장을 다시 평문으로 만드는 복호화 기능

* 해시는 어떻게 암호화가 이루어질까?

  : 평문의 비밀번호를 해시함수(해시 알고리즘)를 이용하여 고정된 길이의 암호화된 문자열로 바꿔 버리는 것

* 해시 알고리즘마다 해시 길이가 다르고 이미 보안이 뚫린 해시 함수가 존재함.

  : MD5, SHA-1, HAS-180은 사용하면 안됨

  : SHA-256, SHA-512 등을 사용하기를 권고함.

  : SHA-512가 보안이 더 좋음

* 해시 알고리즘은 특정 입력에 대해 항상 같은 해시 값을 리턴함.

  : 이 점을 이용해서 인증이 가능함. 어떤 입력인지 몰라도 해시 함수를 이용해서 해시된 값이 일치하면 입력이 같다는 것이 입증됨.

* 해시된 값은 입력이 다른 값이지만 같을 수 있음

  : 입력은 만들어낼 수 있는 평문이 길이 제한이 없다면 무한정으로 만들어 낼 수 있지만 해시된 값은 항상 고정된 길이의 값으로 나타내는 한계가 있기 때문에 다른 입력이지만 해시된 값이 같은 경우가 있을 수 있음.

  ** 중복이 적게 나타날수록 좋은 해시함수임.

* 해커가 무차별적으로 임의의 값을 입력하면서 비밀번호를 알아낼 수 있음 => 이러한 점을 보완하기 위해 비밀번호에 솔트(salt) 값을 넣는 방법이 있고, 해시 함수를 여러 번 돌리는 방법이 있음.





참고 : https://ssoonidev.tistory.com/39?category=626174

https://jeong-pro.tistory.com/92