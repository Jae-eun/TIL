# 가상 메모리(`Virtual Memory`)

>  실행중인 프로세스가 **가상의 공간을 참조**하여 마치 커다란 물리 메모리를 갖고 있는 것처럼 사용할 수 있도록 하는 것

** 가상 메모리를 관리를 하는 세그먼테이션, 페이징 기법 2가지가 있음.

​	: 다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요해서 사용함



* 연속 메모리 관리

  : 프로그램 전체가 하나의 공간에 연속적으로 할당됨

  * 고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할 (내부 단편화)

  * 동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재(외부 단편화)

    

* 가상 주소(`Virtual Address`)가 해결하고 있는 것

  * 선 할당으로 인한 부담
  * 느린 속도의 개선

  

# 세그먼테이션 (`Segmentation`)

> 가변적인 영역인 세그먼트로 분할하여 메모리를 관리하는 것
>
> method, procedure, function, object, variables, stack 등 프로그램의 논리적 단위로 나눔

* 각 영역들의 기능, 권한, 필요한 공간의 크기가 모두 다르기 때문에 효율적인 메모리 관리가 가능하도록 한 것임
* 내부 단편화 X, 외부 단편화 O
* 세그먼트 테이블(`Segment Table`)을 이용하여 세그먼트의 시작주소(`base`)와 세그먼트의 길이(`limit`) 정보를 저장함
  * 각각의 세그먼트를 offset 단위로 관리할 수 있음. 시작 주소와 offset 값으로 실제 물리적 위치로 변환이 가능하므로 관리가 편하고 세그먼트 간에 권한 레벨 관리도 수월해짐
* 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수 있음(외부 단편화)

![OS14-1](https://user-images.githubusercontent.com/34755287/57119448-47043400-6da5-11e9-95da-91cb808de992.png)



# 페이징 (`Paging`)

> 가상 메모리를 고정된 크기로 나누어 메모리를 관리하는 것

* 페이지(`page`) : 잘게 쪼개어진 고정된 크기의 블록

* 프레임(`frame`) : 주기억 장치를 페이지와 같은 크기로 나눈 블록 단위

  * 가상주소는 p(페이지 번호), d(offset) 두가지로 나타내어 페이지 테이블 엔트리에 저장함(`PTE, Page Table Entry`)

  * 가상 주소에서 물리 주소로 변환할 때, p를 이용해 프레임 번호를 알아내고 offset을 더함

    : r(물리 주소) = p'(프레임 번호) + d(offset)

* 외부 단편화 X, 내부 단편화 O

* 항상 프레임의 정수 배로 할당되는데, 이 때 프로세스가 페이지 경계와 일치하지 않는 크기의 메모리를 요구하게 되면 마지막 페이지 프레임은 전부 사용되지 않고 남아버리는 문제가 발생함(내부 단편화)

![img](https://t1.daumcdn.net/cfile/tistory/2446D83555FB8B6127)

* x86 메모리는 세그먼테이션과 페이징을 모두 사용함

  : 세그먼테이션으로 메모리 전체 레이아웃을 분할하고 프로세스가 요구하는 작업들을 동일한 크기로 쪼개어 페이지 단위로 작업을 처리하는 것임

  : 단점 : CPU가 세그먼트 테이블에서 주소 변환을 하고, 그 후 페이지 테이블에서 또 주소 변환을 해야함. 













