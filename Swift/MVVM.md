# MVVM

**Model-View-ViewModel**

UI를 가지는 응용프로그램을 위한 아키텍처 패턴

"뷰의 추상화를 만드는 것이 핵심"

: 뷰의 추상화는 재사용할 수 있고, 테스트하기 쉽다.



* 모델 : 데이터, 비즈니스 논리, 서비스 클라이언트 등으로 구성
* 뷰 : 구성된 UI 요소

* 뷰모델 : '뷰의 모형'. 추상화된 뷰.



구동되는 응용프로그램에서 뷰는 UI 플랫폼이 제공하는 컨트롤들을 조합해 사용자에게 시각적으로 접근하지만 뷰모델은 이러한 뷰를 플랫폼 독립적인 공간에서 추상화한다. 뷰모델은 뷰를 추상화하기 위해 추상화된 뷰 상태를 유지한다. 



모델이 제공하는 정보가 사용자에게 전달될 때, 혹은 그 반대의 경우 원본값이 그대로 사용되기도 하지만 그렇지 않은 경우도 있다. 사용자에게 더 나은 경험을 위한 정보 변환 작업을 위해 뷰모델은 값 변환기(ValueConverters)를 가진다.



뷰는 자신이 가진 상태를 사용자에게 표현할 뿐 아니라 사용자가 응용프로그램에 명령을 내릴 수단을 제공한다. 뷰모델은 이런 기능을 추상화하기 위해 명령(Commands)를 가진다. 명령을 통해 사용자는 모델의 행위를 실행할 수 있다.



뷰 상태, 값 변환기, 명령을 통해 뷰모델은 추상화된 뷰가 된다. 따라서 뷰모델은 개념적으로 사용자와 소통한다. 개념적 공간에서 사용자는 뷰모델의 속성을 통해 정보를 입력하고 뷰모델의 명령을 실행시키며 뷰모델은 자신의 속성을 갱신해 명령 실행 결과와 응용프로그램 상태 변화를 사용자에게 표현한다. 



추상화된 뷰와 물리적인 뷰를 연결해 줄 수단이 필요하다. MVC 패턴에 익숙한 프로그래머라면 컨트롤러가 뷰와 모델 사이의 작업흐름을 제어하는 모습을 떠올릴 것이다. MVVM 패턴에서는 작업흐름 제어보다는 뷰와 뷰모델의 상태를 동기화해 줄 구성요소가 필요한데 데이터 바인딩(data binding)이 그것이다. MVVM 패턴은 완성도 높은 데이터 바인딩 기반 구조에 의존한다. 데이터 바인딩으로 인해 뷰모델의 상태가 변경되면 뷰의 상태가 함께 변경되고 그 반대도 보장된다. 데이터 바인딩이나 그 대체자가 없다면 MVVM 패턴은 구현될 수 없다.



추상화는 구체화에 대한 지식을 가지지 않기 때문에 뷰모델은 뷰에 대해 알지 못한다. 이것은 뷰모델이 플랫폼 독립적이고 다양한 플랫폼에서 재사용될 수 있음을 의미한다. 응용플랫폼에 종속된 코드는 생명주기 제약이 많지만 뷰모델 인스턴스는 언제든지 즉시 생성될 수 있다. 프로그래머는 단위 테스트 케이스를 통해 뷰모델에 구현된 응용프로그램 요구사항을 이른 시점에 검증할 수 있고 테스트 주도 개발 도입도 쉽다. 



재사용성과 테스트 용이성 외에 뷰모델이 추상화된 뷰로서 가지는 커다란 장점은 응용프로그램의 많은 부분이 뷰 독립적으로 설명되고 구현된다는 것이다. 응용프로그램은 복잡한 컨트롤러 논리 없이 단순한 구조를 유지할 수 있다. 이것이 가장 큰 가치이다. 



1) 'Blendability'라는 용어가 있을 정도로 MVVM에서 Blend는 중요

2) 'Zero code-behind'에 집착하면 뷰모델이 뷰에 대한 간접적 지식을 갖게 되는 경우가 있다. 레이아웃 크기가 뷰모델 속성으로 바인딩되는 것 등이다. 방치하면 뷰모델과 뷰는 간접적 뒤엉킴에 시달리고 좋지 않은 것이다. 뷰에 코드를 허용하고 관심사를 분리하는 데에 집중해라.

3) 최상위 뷰모델의 이름 'ApplicationModel'



























