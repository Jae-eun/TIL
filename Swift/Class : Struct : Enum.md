# CLASS

* 인스턴스 : 특정 타입이 메모리에 적재된 시점의 타입

* **단일 상속**만 가능

* (인스턴스/타입) 메서드, (인스턴스/타입) 프로퍼티

* **참조타입** call by reference

  : 데이터를 전달할 때 값의 메모리 위치를 전달한다.

  : 데이터를 참조하는 곳 어디서든 원본에 접근이 가능하다.

* iOS 프레임워크의 대부분이 클래스로 구성됨





# STRUCT

* 상속 불가능

* (인스턴스/타입) 메서드, (인스턴스/타입) 프로퍼티

* **값타입** call by value

  : 데이터를 전달할 때 값을 복사하여 전달한다.

* Swift의 대부분은 구조체로 구성됨

* 시스템 리소스를 적게 차지한다.

* 안정성이 더 높다. 원본을 그대로 두고 복사하기 때문에 원본을 지킬 수 있다. 

* 비교적 간단한 데이터 갓을 캡슐화하는데에 쓴다.

* 구조체를 사용하는 좋은 예

  : Double 형을 갖는 width와 height 프로퍼티의 캡슐화를 하는 기하학적 모형의 사이즈

  : Int형을 갖는 start와 length 프로퍼티의 캡슐화를 하는 시리즈의 범위에 접근하는 방법

  : Double 형을 갖는 x, y와 z 프로퍼티의 캡슐화를 하는 3차원 좌표시스템의 포인터

  : 이외의 경우에는 클래스로 정의하며, 레퍼런스로 전달되고 관리되는 클래스의 인스턴스를 생성하세요. 실질적으로는 대부분의 사용자 데이터 형은 구조체가 아닌 클래스로 정의되어야 합니다.





# 공통점

1. 서로 다른 타입(자료형)들을 하나로 묶을 수 있다.
2. 이러한 묶은 자료형들을 새로운 타입처럼 사용 가능하다.
3. 클래스/구조체 안에서 함수/프로퍼티 정의가 가능하다.
4. extension이 가능하다.





# ENUM

* 상속이 불가능하다.
* (인스턴스/타입) 메서드, (인스턴스/타입) 연산 프로퍼티
* 값이 없을 수 있다.
* 원시값은 문자열, 글자, 정수, 부동 소수점 타입이 될 수 있다.
* 각각의 원시값은 열거형 정의 안에서 반드시 유일해야 한다.
* 원시값으로 정수가 사용되었는데 일부에 아무 값도 설정하지 않은 경우 자동 증가한다.
* 전달한 원시값에 해당하는 케이스가 없을 수 있기 때문에 원시값을 통한 인스턴스 생성은 옵셔널 값으로 반환된다.















