# 1. 잡과 태스크

### 잡(`Job`)

* 사용자의 입장에서 보았을 때 컴퓨터에게 시키는 일의 단위
* 잡 안에는 여러 프로그램의 실행이 포함됨



### 잡 관리

* OS는 잡의 실행 순서와 잡이 정상적으로 처리되고 있는지를 관리함
* 잡 스텝(`Job Step`) : 잡을 작게 나눈 처리 단위
* 잡 제어 언어(`JCL`) : 잡의 실행 방법을 지정하는 언어
* 잡을 실행순으로 나열 -> 잡 스텝을 순서대로 처리 -> 잡의 상태를 기록



### 태스크(`Task`)

* OS 입장에서 본 작업 단위
* 잡 스텝을 태스크로 분해하여 CPU에 처리를 의뢰함



### 태스크 관리

* OS는 잡 관리로부터 넘겨 받은 태스크의 상태를 관리하거나 CPU의 처리 할당을 수행함



# 2. 스루풋(`Throughput`)

### 스루풋

* **OS의 단위 시간당 처리 능력**
* 스루풋이 높으면 처리 효율이 좋음



### 리스폰스 타임과 턴어라운드 타임

* 명령 입력 -> [처리 조건 입력 시간 -> CPU의 처리 시간 -> 처리 결과 출력 시간] -> 다음 명령 입력 가능
* 리스폰스 타임(응답 시간) : CPU의 처리 시간
* 턴어라운드 타임 : CPU의 처리 시간 + 입출력 시간



### 스풀(`Spool`)

* CPU로부터 입출력 장치로 가는 명령을 메모리와 같이 비교적 고속인 기억 장치에 일시적으로 저장하는 것
* 스풀 파일 : 디스크에 저장된 스풀 데이터



# 인터럽트 - 1

### 인터럽트(`Interrupt`)

* 실행 중인 프로그램을 중단하고 우선순위가 높은 다른 프로그램에서 CPU를 할당하여 실행하는 것
* 중단된 처리 내용은 메모리에 일시적으로 저장됨



### 내부 인터럽트(소프트웨어 인터럽트)

* 실행중인 프로그램이 원인이 되어 일어나는 인터럽트

  > ** 프로그램 인터럽트
  >
  > 오버플로어(`Overflow` : 계산 시 자리 넘침) : 쓰기가 허가되지 않은 메모리 영역에 액세스했을 때
  >
  > 페이지 폴트(`Page Fault`) : 무효한 메모리를 참조함
  >
  > 트레이스(`Trace`) : 디버그를 위해 프로그램을 한 명령씩 실행함
  >
  > 슈퍼바이저 콜(`Superviser Call`) : 시스템 콜을 실행함
  >
  > 명령 코드 이상 : 무효한 명령을 실행함



# 인터럽트 - 2

### 외부 인터럽트(하드웨어 인터럽트)

* 주변 기기의 입출력 동작이나 하드웨어 고장, 오작동으로 인해 일어나는 인터럽트

  > ** 기계 체크 인터럽트
  >
  > * 전원 이상이나 하드웨어에 장애가 발생했을 때 발생
  > * 인터럽트 중에서 가장 우선됨
  >
  > ** 타이머 인터럽트
  >
  > * 일정 시간 또는 일정 시간마다 하드웨어로부터 발생하는 인터럽트
  > * 시간이 경과했다는 것을 OS에게 알림
  >
  > ** 입출력 인터럽트
  >
  > * 주변 기기의 입출력 동작이 완료되었을 때와 같이 상태가 변화했을 때 발생
  > * 프린터의 용지가 떨어졌을 때도 발생
  >
  > ** 콘솔 인터럽트
  >
  > * 사용자가 키보드와 같은 입출력 장치를 조작하면 발생
  > * 사용자로부터 입력이 있었다는 것을 OS에게 알림



# 5. 프로세스란?

### 프로세스(`Process`)

* **메모리상에 할당된 프로그램**
* 하나의 프로그램으로부터 여러 개의 프로세스를 만들 수 있음
* 프로그램의 인스턴스라고도 함



### 멀티태스킹(`Multi-tasking`)

* **OS 관리하에서 여러 개의 태스크(프로세스)가 병행하여 작동하는 것**
* 태스크를 순서대로 CPU에 할당하고 있기 때문에 여러 개의 태스크가 동시에 작동하고 있는 것처럼 보임
* 태스크 전환에는 약간의 시간(오버헤드)가 걸림



### 시분할 처리 시스템(`TSS, Time Sharing System`)

* 여러 사용자가 한 대의 고성능 컴퓨터를 공유하여 사용할 때, **CPU의 사용 권한을 사용자에게 순서대로 단시간 할당하는 시스템**
* 사용자에게는 자신이 컴퓨터를 점유하고 있는 것처럼 보임



# 6. 프로세스 관리

### 프로세스 상태

* 대기 상태  : 입출력 동작을 기다리고 있는 상태
* 실행 가능 상태 : CPU의 사용 권한 할당을 기다리고 있는 상태
* 실행 상태 : 프로세스에 CPU의 사용 권한이 할당되어 실행되고 있는 상태



### 디스패치와 프리엠션

* **디스패치(`Dispatch`)** : OS가 가장 우선순위가 높은 실행 가능 상태의 프로세스에 대해 CPU의 사용 권한을 할당하는 것
* **프리엠션(`Preemption`)** : 인터럽트에 의해 CPU의 할당을 해제하는 것



# 7. 멀티태스킹의 종류

### 프리엠티브(`Preemptive`)

* OS가 실행 가능 상태인 태스크에게 CPU의 사용권을 할당하고 강제적으로 태스크를 전환하여 관리하는 것

* 주로 사용됨

  > 타임 슬라이스 : CPU의 사용 권한을 할당하는 단위 시간



### 논프리엠티브(`Non-preemptive`)

* 실행 중인 태스크가 처리를 수행하지 않는 시간을 자발적으로 해제함을써 다른 태스크와 동시에 실행할 수 있도록 하는 것
* CPU를 해제하지 않는 태스크가 있으면 OS 전체의 동작이 정지되는 경우도 있음



# 8. 프로세스 제어

### 프로그램 상태어(`PSW : Program Status Word`)

* 인터럽트로 인해 중단된 프로그램의 상태나 연산의 종료 상태를 저장해 두는 레지스터



### 프로세스 제어 블럭(`PCB : Process Control Block`)

* 각 프로세스의 CPU 상태(컨텍스트)나 프로세스의 상태를 저장해 두는 메모리 영역



### 컨텍스트 스위치

* 인터럽트로 인해 프로세스를 전환할 때 OS가 컨텍스트를 PCB에 저장하고 복원하는 것



# 9. 스케줄링(`Scheduling`)

### 스케줄링

* OS가 여러 개의 프로세스를 처리할 때, **CPU를 할당할 순서를 정하는 것**
* 스케줄러 : 스케줄링을 하기 위한 소프트웨어
* 스루풋이 향상되고 응답 시간이 단축되도록



### 스케줄링의 종류

* **라운드 로빈 방식(`Round Robin Scheduling`)** : 프로세스가 기다리고 있는 순서대로 일정 시간씩 CPU를 할당해서 시간이 초과한 프로세스를 맨 마지막으로 돌리는 방식

* **우선순위 방식** : OS가 프로세스의 우선순위를 정해서 우선순위가 높은 프로세스부터 실행해 나가는 방식. 주로 사용됨. 데드락 발생 가능성이 있음

   



# 10. 프로세스의 분기

* 프로세스의 일을 분담하여 작업 효율을 올리는 방법

  

### fork와 exec

* `fork` : UNIX 계열 OS에서 시스템 콜에 의해 프로세스를 복사하는 것

  > 부모 프로세스 : 복사되는 쪽, 자식 프로세스 : 복사된 쪽
  >
  > 자식 프로세스용 새 PCB와 메모리 공간이 마련됨

* `exec` : 자식 프로세스에서 다른 프로그램을 실행하도록 지시하는 것



### wait

* 자식 프로세스의 처리가 끝나면 부모 프로세스에게 신호가 보내지므로 이것을 기다림으로써 부모는 자식 프로세스의 종료까지 대기할 수 있음
* wait 시스템 콜에 의해 자식 프로세스에게 마련되었던 PCB와 메모리가 제거됨
* 하나의 wait 처리가 완료될 때까지 다른 자식 프로세스의 종료 시그널을 받을 수 없음



# 11. 프로세스의 동기

### 배타 제어

* 여러 개의 프로세스가 파일이나 데이터베이스에 동시에 액세스하면 데이터의 무결성이 손상될 수 있으므로, **처리가 끝날 때까지 하나의 프로세스에게 자원을 독점시키는 것**



### 세마포(`Semaphore`)

* 데드락을 피하기 위한 방법
* 정해진 수 이상의 프로세스가 공유 자원에 동시 액세스하지 않도록 카운터를 사용하여 제어하는 장치
* P 조작(획득)과 V 조작(해제)으로 '통행 가능', '통행 불가'와 같은 두 가지 상태를 관리함
* 크리티컬 섹션 : 프로그램 중 배타 제어가 필요한 부분(P 조작부터 V 조작까지의 처리)
* P 조작 한 번에 카운터가 1씩 감소함
* V 조작 한 번에 카운터가 1씩 증가함
* 카운터가 이미 '0'인 경우는 통행 불가함



# 12. 데드락(`Dead lock`)

### 데드락

* 2개의 프로세스가 공유 자원을 잠근 채로 서로의 공유 자원에 액세스하려고 하면 양쪽 프로세스가 모두 영구적으로 대기 상태가 되는 것
* 배타 잠금 : 누군가가 조작중인 데이터에 대해 참조나 변경을 할 수 없음
* 공유 잠금 : 조작중인 데이터에 대해 참조는 할 수 있으나 변경은 할 수 없음



### 뮤텍스(`Mutex`)

* 데드락을 피하기 위한 방법
* 세마포의 카운터 초기값이 1인 경우와 같음
* P를 조작하면 하나만 통행할 수 있음
* 공유 자원에 액세스하고 있는 프로세스 A가 V 조작을 하지 않으면 다른 프로세스는 통행할 수 없음
* 여러 개의 프로세스에 의한 공유 자원 경쟁이 없어지므로 배타 제어에 적합함



# 13. 프로세스 간 통신

### 프로세스 간 통신

* 프로세스끼리는 다른 메모리 공간을 참조하기 때문에 서로 어떤 데이터를 갖고 있는지 알 수 없음
* 프로세스끼리 통신을 해서 데이터를 주고 받는 기능이 있음



#### 메시지 큐

* 프로세시끼리 OS의 메시지 기능을 사용하여 1대 1로 통신할 수 있음
* 메시지를 넣는 장소



#### 파이프

* 여러 개의 프로세스 입출력을 연결하는 장치
* 파이프는 fork한 부모 자식 프로세스 간에 사용됨
* 일방통행이기 때문에 상대 프로세스별로 파이프가 다름



#### 이름 붙은 파이프

* 파이프에 이름을 붙임으로써 부모 자식 프로세스가 아니어도 프로세스 간 통신을 할 수 있음



# 14. 공유 메모리와 스레드

### 공유 메모리

* 여러 개의 프로세스에서 공통으로 사용할 수 있는 메모리 영역
* 시스템 콜에 의해 작성됨
* 프로세스 간의 통신에 사용할 수 있음
* `Attach` : 공유 메모리에 접속하는 것
* `Detach` : 공유 메모리의 접속을 끊는 것



### 스레드(`Thread`)

* 프로세스 안의 프로그램 실행의 흐름
* 멀티스레드(`Multi-Thread`) : 분기가 가능하여 여러 개의 스레드를 동시에 실행할 수 있음



### 스레드와 프로세스의 차이

* **동일한 프로세스의 스레드는 같은 메모리 공간을 참조함**
* 메모리의 이용 효율이 올라감
* CPU를 사용하는 최소 단위
* `Light Weight Process` 라고도 부름



# 멀티 프로세서(`Multi-Processor` : 다중 처리기)

* 1대의 컴퓨터가 여러 개의 CPU(마이크로 프로세서)를 갖고 있는 것
* 처리를 병렬로 실행해서 결과를 고속으로 출력함
* 장애가 발생했을 때 정상인 CPU만으로 처리를 계속할 수 있음
  * 강 결합 멀티 프로세서(`Tighty Coupled Multi-Processor`) : 하나의 OS가 여러 개의 CPU를 가지고 각 CPU가 하나의 메모리를 공유하는 방식
  * 약 결합 멀티 프로세서(`Loosely Coupled Multi-Processor`) : CPU별로 메모리와 OS를 가지고 분산되는 OS를 제어하는 방식



#### SIMD(`Single Instruction Multiple Data`)

: 동일한 명령을 여러 개의 CPU에게 보내 여러 개의 데이터에 대해 처리를 병렬로 실행하는 방식



#### MISD(`Multiple Instruction Single Data`)

: 여러 개의 명령을 CPU에게 보내 동일한 데이터에 대해 다른 처리를 병렬로 실행하는 방식



#### MIMD(`Multiple Instruction Multiple Data`)

: 여러 개의 명령을 여러 개의 CPU에게 보내 여러 개의 데이터에 대해 여러 개의 다른 처리를 병렬로 실행하는 방식