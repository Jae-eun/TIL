# 1. 메모리의 종류

### 메모리의 특성에 따른 종류

* **RAM(`Random Access Memory`)** : 휘발성 메모리, 데이터의 읽기 쓰기가 가능하지만 컴퓨터의 전원을 끄면 기록한 내용이 사라짐
* **ROM(`Read Only Memory`)** : 비휘발성 메모리, 일반적으로 데이터 읽기 전용. 컴퓨터의 전원을 꺼도 기록한 내용이 사라지지 않음



### RAM

> 주로 프로그램의 작업 영역으로 사용됨



* DRAM(`Dynamic RAM`) 

  > * 메인 메모리나 VRAM(`Video Ram, 화면 표시용 메모리`)으로 사용됨
  > * 리프레시 동작(정보를 보존 및 유지하기 위해 기억 내용을 다시 쓰는 것)이 필요함
  > * 소비 전력이 적음
  > * 대용량임
  > * 처리가 비교적 느림

* SRAM(`Static RAM`) 

  > * FlipFlop 회로(리프레시가 불필요한 회로) 구조
  > * 소비 전력이 큼
  > * 저용량임
  > * 처리 속도가 빠름



### ROM

> 시스템 체크나 BIOS 정보 등을 저장하는 데 사용됨
>
> 쓰기가 가능한 것도 있음(횟수 제한)



* 마스크 ROM 

  > * ROM의 제조 공정에서 마이크로 프로그램 등을 기록함
  > * 기록 내용은 변경할 수 없음

* PROM(`Programmable ROM`)

  > * EPROM(`Erasable Programmable ROM`) : 자외선으로 다시 쓸 수 있음
  > * EEPROM(`Electrically Erasable Programmable ROM`) : 전기적으로 다시 쓸 수 있음. BIOS를 저장하는 데 사용함
  > * 플래시 메모리 : 전기적으로 다시 쓸 수 있음. 일괄 또는 부분적으로 삭제하거나 다시 쓰기가 가능함. USB 메모리, SD 카드, SSD 드라이브 등에 사용됨



# 2. 메모리 공간

### 메모리 공간

* 주소라 불리는 번지를 붙여서 각 영역을 식별함

  > * 32비트 : 최대 메모리 용량 4GB(2^32byte)
  > * 64비트 : 최대 메모리 용량 16EB(2^64byte)



### 메인 메모리의 용도

> 계산을 할 때 많은 데이터를 기억할 수 있게 함



* **힙(`Heap`)** : 파일로부터 읽어들인 데이터나 네트워크상에서 수신한 데이터를 저장할 때와 같이 필요한 만큼만 확보하여 사용하는 메모리 영역. 필요가 없어지면 해제함
* **스택(`Stack`)** : 프로그램 실행 중에 이용하는 변수의 내용을 일시적으로 저장하는 메모리 영역. 프로그램의 한 단위(함수 등)가 시작될 때 자동적으로 확보되고 처리가 종료되면 자동으로 해제됨. LIFO 형식. 사용할 수 있는 용량이 정해져 있으므로 너무 많이 사용하면 오버플로가 발생함



# 3. 가상 기억

> 메인 메모리보다 큰 기억 영역을 제공하는 장치



### 물리 메모리

* 컴퓨터에 실제로 장착되어 있는 메모리
* 물리 메모리가 OS가 다룰 수 있는 메모리의 최대 용량을 모두 갖고 있는 것은 아님



### 가상 메모리

* 최근의 OS는 하드디스크 안에 페이징 파일(스왑 파일)을 작성함. 이 파일과 물리 메모리를 합쳐서 가상의 메모리 영역으로 간주함으로써 물리 메모리의 용량을 초과한 메모리를 다룰 수 있음
* '물리적인 메모리 공간'이라고도 함



### 스왑

* 메모리 용량이 부족할 때 물리 메모리와 페이징 파일 사이에서 메모리상의 프로세스를 일시적으로 교환하는 것
* 우선순위가 낮은 프로세스를 페이지 파일로 저장해서 점유하고 있던 메인 메모리를 해제함. 우선순위가 높은 프로세스를 메인 메모리에 로드함.
* 하드디스크에 자주 액세스하므로 퍼포먼스 저하로 이어짐
* 스왑 아웃 : 메모리에서 하드디스크로 대피하는 것
* 스왑 인(로드) : 하드디스크에서 메모리로 되돌리는 것



# 4. 메모리 확보와 해제

### 메모리 확보와 해제

* 할당(`Allocation`) : OS가 프로세스나 데이터의 메모리 영역을 확보하는 것
* 확보한 메모리 영역은 처리 종료 시 해제해야 함



### 리로케이션(`Relocation : 재배치`)

* 한 번 확보한 메모리 영역의 위치를 변경하는 것
* 동적 재배치(`Dynammic Relocation`) : 실행 중인 프로그램의 위치를 변경하는 것. 가상 메모리상의 주소를 물리 메모리 주소로 변환할 때 발생



### 가비지 콜렉션(`Garbage Collection`) 

* 힙 영역이 가득 차서 액세스할 수 없을 때는 불필요한(사용이 끝난) 메모리 영역으 자동으로 해제함



### 컴팩션(`Compaction : 조각 모음`)

* 단편화된 메모리의 미사용 영역을 모아서 연속으로 이용할 수 있는 메모리 영역으로 만드는 것



# 5. 데이터 저장 순서

### 메모리 추출 알고리즘

> OS가 데이터를 읽어들일 때 빈 용량이 없으면 기존의 데이터를 메모리로부터 꺼내야 함



* LIFO(`Last In First Out`) 

  > * 메모리에 나중에 넣은 데이터를 먼저 꺼내는 방법
  >
  > * **스택** 저장 방법
  > * `PUSH` : 스택에 저장하는 것
  > * `POP` : 스택에서 꺼내는 것

* FIFO(`First In First Out`) 

  > * 메모리에 먼저 넣은 데이터를 먼저 꺼내는 방법
  > * 잡 관리의 저장 방법
  > * **큐(`Queue`)** : 데이터의 대기 행렬
  > * `Enqueue` : 큐에 저장하는 것
  > * `Dequeue` : 큐에서 꺼내는 것



### 연결 리스트(`Linked List`)

* 하나의 데이터가 요소와 포인터로 구성되어 포인터가 다음 데이터의 메모리 주소를 가리킴으로써 연속한 데이터를 저장하는 방법. 
* 데이터가 순서대로 있는 것은 아님. 
* 쌍방향 리스트, 환형 리스트도 있음



# 매핑(`Mapping`)

### 매핑

* OS가 물리 메모리와 가상 메모리 사이에서 프로그램이나 데이터를 대응시키는 것



* **페이징(`Paging`) **

  > * 고정 길이 페이지 단위(4KB)로 매핑을 수행하는 것
  > * 페이지 인 : 가상 메모리에서 우선순위가 높은 페이지를 물리 메모리의 프레임으로 전송함
  > * 페이지 아웃(대피) : 사용하지 않는 프레임을 물리 메모리에서 가상 메모리로 전송함
  > * **페이지 폴트(`Page Fault`)** : 물리 메모리에 페이지 프레임(메모리의 빈 영역)이 없으면 발생하는 인터럽트

* 스래싱(`Thrashing`) : 페이징이 빈번히 일어나는 것. CPU 이용 효율 저하의 원인이 됨

* **세그먼테이션(`Segmentation`) **

  > * 가변 길이 세그먼트 단위로 매핑을 수행하는 것
  > * 세그먼트에는 프로세스에서 사용하는 메모리를 연속해서 할당함
  > * 롤 아웃(대피)
  > * 롤 인 : 우선순위가 높은 세그먼트를 전송함
  > * 세그먼테이션을 빈번히 수행하면 메모리 단편화(`Fragmentation`)가 발생하므로 컴팩션을 수행해야 할 수 있음
  > * 메모리 단편화 : 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태
  > * **내부 단편화(`Internal Fragmentation`)** : 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황
  > * **외부 단편화(`External Fragmentation`)** : 메모리가 할당되고 해제되는 작업이 반복될 때 중간중간에 생긴 사용하지 않는 작은 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 메모리 할당을 할 수 없는 상황



# 7. 메모리 맵(`Memory Mapped I/O`)

### 메모리 맵 I/O

* 입출력 기기를 제어할 때 메인 메모리와 I/O 주소 공간을 공유하는 방식
* I/O 주소 공간도 메모리의 일부로 취급함
* 주소 버스를 통해 메모리 주소를 지정함
* CPU는 데이터 버스를 통해 메모리와 주고 받기를 함
* CPU가 지정한 메모리를 통해서 디바이스 또는 CPU로부터 명령이나 데이터를 기록함



### DMA(`Direct Memory Access`)

* CPU를 거치지 않고 입출력 장치와 입출력 장치와 메모리 사이에 직접 데이터를 주고받는 방법
* 메모리와 입출력 기기 사이에 놓인 DMA 컨트롤러가 CPU를 대행하여 입출력 기기의 동작을 제어함
* DMA를 통해 디바이스로부터 명령이나 데이터를 기록함
* DMA 컨트롤러는 인터럽트 처리도 대행함
* CPU에 부담을 주지 않기 때문에 큰 데이터를 전송할 때 적합함



# 바이트(`byte`)와 비트(`bit`)

> 데이터 크기를 나타내는 단위
>
> 2진수로 취급함
>
> = 이유 : 컴퓨터의 기본 구조는 전자 회로에 전류가 흐르고 있는지 아닌지로 되어 있음.
>
> ​			: 전류가 흐르지 않는 상태 0(OFF) / 전류가 흐르고 있는 상태 1(ON)

* 비트(`bit : binary digit`) : 0과 1, 두 가지로 데이터를 나타내는 단위. 컴퓨터가 취급하는 최소 단위

* 바이트 : 8비트를 한 세트로 한 정보량의 단위. 1바이트 = 8비트. 1바이트는 0이나 1이 8개 나열됨. 256개(2^8)의 데이터를 나타낼 수 있음

  > KB(킬로바이트) : 1KB = 1024byte
  >
  > MB(메가바이트) : 1MB = 1024KB
  >
  > GB(기가바이트) : 1GB = 1024MB
  >
  > TB(테라바이트) : 1TB = 1024GB