# 그래프 Graph 

> 노드와 노드를 연결하는 정점(`vertex`)과 간선(`edge`)을 모아 놓은 자료구조 

* 네트워크 구조를 추상화한 모델
* 연결되어 있는 객체 간의 관계를 표현할 수 있음
* G = (V, E) 



### 무방향 그래프(`Undirected Graph`)

![img](https://blog.kakaocdn.net/dn/0ZsjG/btqKjcbPzFp/Emai2Mc2IWMIAENKHr4Is1/img.png)

* 무방향 그래프의 간선은 간선을 통해서 양방향으로 갈 수 있음 
* 정점 A와 정점 B를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현. 
  * (A, B)와 (B, A)는 동일



### 방향 그래프(`Directed Graph`)

![image](https://user-images.githubusercontent.com/12438429/123076690-57c80600-d454-11eb-8e3e-d0be5018e93e.png)

* 간선에 방향성이 존재하는 그래프 
* A -> B로만 갈 수 있는 간선은 <A, B>로 표시
  * <A, B> 와 <B, A> 는 다름



### 가중치 그래프(`Weighted Graph`)

![image](https://user-images.githubusercontent.com/12438429/123076857-79c18880-d454-11eb-869a-b6dc85ccddeb.png)

* 간선에 비용이나 가중치가 할당된 그래프
* 네트워크(`Network`) 라고도 함



### 연결 그래프(`Connected Graph`)

* 무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우
* Ex) 트리 : 사이클을 가지지 않는 연결 그래프  



### 비연결 그래프(`Disconnected Graph`)

* 무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 경우



### 사이클(`Cycle`)

* 단순 경로의 시작 정점과 종료 정점이 동일한 경우 
  * 단순 경로(`Simple path`) : 경로 중에서 반복되는 정점이 없는 경우



### 완전 그래프(`Complete Graph`)

![image](https://user-images.githubusercontent.com/12438429/123076905-8645e100-d454-11eb-8910-e245fd04367b.png)

* 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프 

  

### 오일러 경로(`Eulerian tour`)

* 그래프에 존재하는 모든 간선(`edge`)을 한 번만 통과하면서 처음 정점(`vertext`)으로 되돌아오는 경로
* 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 존재함



## 그래프의 구현

### 1. 인접 리스트(`Adjacency List`)

* 모든 정점을 인접 리스트에 저장함. 즉, 각각의 정점에 인접한 정점들을 리스트로 표시함.

  * 배열(or 해시테이블)과 배열의 각 인덱스마다 존재하는 또 다른 배열을 이용해서 표현

  ```swift
  Ex)
  0: 1
  1: 2
  2: 0, 3
  3: 2
  ```

  * 정점의 번호만 알면 배열의 인덱스로 각 정점의 리스트에 쉽게 접근할 수 있음 

* 무방향 그래프에서는 (a, b) 간선이 두 번 저장됨

* 트리에서는 특정 노드 하나(루트 노드)에서 모든 노드로 접근이 가능

* 그래프에서는 특정 노드에서 다른 모든 노드로 접근이 가능하지는 않음 



### 2. 인접 행렬(`Adjacency Matrix`)

* `N x N Boolean 행렬`로써, `matrix[ i ][ j ]` 가 __true__ 면 i -> j 로의 간선이 있다는 뜻임 
* 정점의 개수가 N인 그래프는 간선의 수와 상관없이 항상 N^2개의 메모리 공간이 필요함 
* 무방향 그래프를 표현하면 대칭 행렬(`Symmetric Matrix`)
* 인접 리스트를 사용한 그래프 알고리즘(BFS) 등을 인접 행렬에서도 사용할 수 있음
  * 인접한 노드를 찾기 위해서 모든 노드를 전부 순회해야 하기 때문에 효율성이 약간 떨어짐



### 인접 리스트와 인접 행렬 중에서 선택할 때 

### 인접 리스트

* 그래프 내에서 적은 숫자의 간선 만을 가지는 __희소 그래프(`Sparse Graph`)__ 의 경우 
* 장점
  * 인접한 노드를 쉽게 찾을 수 있음
  * 그래프에 존재하는 모든 간선의 수는 `O(N+E)` 안에 알 수 있음(인접 리스트 전체를 조회)
* 단점
  * 간선의 존재 여부와 정점의 차수 : 정점 i의 리스트에 있는 노드의 수 즉, 정점 차수 만큼의 시간이 필요함 

### 인접 행렬

* 그래프에 간선이 많이 존재하는 __밀집 그래프(`Dense Graph`)__의 경우 
* 장점
  * 두 정점을 연결하는 간선의 존재 여부 `M[i][j]` 를 O(1) 안에 즉시 알 수 있음
  * 정점의 차수는 O(N) 안에 알 수 있음(인접 배열의 i번째 행 또는 열을 모두 더함)
* 단점
  * 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 함
  * 그래프에 존재하는 모든 간선의 수는 `O(N^2)` 안에 알 수 있음 (인접 행렬 전체를 조사함)

# 트리 Tree

> 계층적 관계를 표현하는 자료구조

* 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 무방향 그래프(`Graph`)의 특수한 형태
* 나무가 하나의 뿌리(`root`)에서 줄기가 나와 가지(`branch`)로 나누어지는 것처럼 어떤 하나의 집합(레코드나 디렉토리 등)으로부터 하위 레벨로 가지가 나오는 집합 관계를 갖는 계층 구조



### 순회

> * 중위 : 루트를 2번째로 탐색(`left-root-right`)
> * 전위 : 루트를 1번째로 탐색(`root-left-right`)
> * 후위 : 루트를 3번째로 탐색(`left-right-root`)
> * 레벨 순서 : 노드를 레벨 순서로 방문. BFS와 동일하므로 큐를 통해 구현할 수 있음



### 이진 트리

> 자식 노드가 2개까지만 있는 트리



### 이진 탐색 트리

> 이진 트리에 값이 정렬되는 데이터 저장 규칙을 적용한 것

* 이진 탐색 트리 노드에 저장된 값은 유일함
* 루트 노드의 값이 왼쪽 서브 트리를 구성하는 노드의 값보다 큼
* 루트 노드의 값이 오른쪽 서브 트리를 구성하는 노드의 값보다 작음
* 왼쪽과 오른쪽 서브 트리를 별도로 분리해도 이진 탐색 트리임
* 시간 복잡도
  * 이상적인 상황에서 탐색/삽입/삭제 모두 `O(logN)`
  * 균형이 깨지면, 최악 `O(N)`
* 장점 : 이진 탐색의 효율적인 빠른 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능



### AVL 트리

* 한 쪽으로 값이 치우치는 이진 균형 트리(`Balanced Search Tree, BST`) 의 한계점을 보완하기 위해 만들어진 균형 잡힌 이진 트리
* 항상 좌/우로 데이터를 균형 잡힌 상태로 유지하기 위해 추가적인 연산을 함 



### 레드블랙 트리

* 모든 노드를 빨간색이나 검은색으로 색칠하여, 연결된 노드들은 색이 중복되지 않도록 관리함



###  최소 스패닝 트리 (`Minimum Spanning Tree: MST`)란?

> 그래프의 edge weight 값이 최소인 스패닝 트리
>
> 스패닝 트리 : 그래프의 모든 vertex가 cycle 없이 연결된 상태  





##💡 짚고 넘어가기



### * 그래프와 트리의 차이점 

> * 그래프는 노드와 노드를 연결하는 간선을 모아놓은 자료구조
> * 그래프는 네트워크 구조를 가져, 부모-자식 노드 간의 개념이 없음
> * 그래프에서는 노드 간 다양한 경로를 구할 수 있지만, 트리는 하나의 경로만 가짐
> * 방향이 없을 수도 있고, 사이클이 있을 수도 있음
> * 간선의 수가 각각 다르고, 없을 수도 있음
>
> 
>
> * 트리는 그래프의 일종으로, 순환되지 않는 방향 그래프
> * 트리는 계층 구조를 가져, 루트 노드를 제외한 자식 노드는 한 개의 부모 노드만 가짐
> * 방향 그래프이고, 사이클은 있을 수 없음 
> * 노드가 N인 트리는 항상 N-1개의 간선을 가짐



### * 최소 스패닝 트리(`MST`)를 구하는 2가지 방식과 차이점

* 크루스칼(`kruskal`) 과 프림(`prim`) 알고리즘으로 만들 수 있음 
* 크루스칼은 가중치를 기준으로 정렬한 후에 MST가 될 때까지 간선을 하나씩 선택 또는 삭제해 나가는 방식. 사이클을 형성하는 간선은 추가하지 않고 간선의 수가 정점의 수보다 하나 작을 때 MST가 완성된다.(그리디 알고리즘)
* 프림은 시작 정점부터 단계적으로 트리를 확장하는 방법



### * 이진 트리의 문제점

> * 루트 노드의 데이터 값이 전체 데이터의 중간 값을 가지지 못한 경우, 한쪽으로 데이터가 편향되어 검색 성능이 저하됨
> * 최악의 경우, 루트 노드가 전체 데이터 값 중 최소/최대 값을 가지면 `linked list`와 같은 형태가 발생할 수도 있음
> * 새로운 데이터 노드를 추가할 때, 전체 균형을 잡을 수 있도록 재조정해야 함











