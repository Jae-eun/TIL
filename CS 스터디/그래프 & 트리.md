# 그래프 Graph 

> 노드와 노드를 연결하는 정점(`vertex`)과 간선(`edge`)을 모아놓은 자료구조 

* 네트워크 구조를 추상화한 모델
* 





# 트리 Tree

> 계층적 관계를 표현하는 자료구조

* 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 무방향 그래프(`Graph`)의 특수한 형태
* 나무가 하나의 뿌리(`root`)에서 줄기가 나와 가지(`branch`)로 나누어지는 것처럼 어떤 하나의 집합(레코드나 디렉토리 등)으로부터 하위 레벨로 가지가 나오는 집합 관계를 갖는 계층 구조



### 순회

> * 중위 : 루트를 2번째로 탐색(`left-root-right`)
> * 전위 : 루트를 1번째로 탐색(`root-left-right`)
> * 후위 : 루트를 3번째로 탐색(`left-right-root`)
> * 레벨 순서 : 노드를 레벨 순서로 방문. BFS와 동일하므로 큐를 통해 구현할 수 있음



### 이진 트리

> 자식 노드가 2개까지만 있는 트리





### 이진 탐색 트리

> 이진 트리에 데이터 저장 규칙을 적용한 것

* 이진 탐색 트리 노드에 저장된 값은 유일함
* 루트 노드의 값이 왼쪽 서브 트리를 구성하는 노드의 값보다 큼
* 루트 노드의 값이 오른쪽 서브 트리를 구성하는 노드의 값보다 작음
* 왼쪽과 오른쪽 서브 트리를 별도로 분리해도 이진 탐색 트리임
* 시간 복잡도
  * 이상적인 상황에서 탐색/삽입/삭제 모두 `O(log N)` // 이진 탐색 트리의 탐색, 삽입, 삭제의 시간 복잡도는 O(h)
  * 편향되는 경우, 최악 `O(N)`
  * 
* 장점 : 이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능



### AVL 트리

* 한 쪽으로 값이 치우치는 이진 균형 트리(`Balanced Search Tree, BST`) 의 한계점을 보완하기 위해 만들어진 균형 잡힌 이진 트리
* 항상 좌/우로 데이터를 균형 잡힌 상태로 유지하기 위해 추가적인 연산을 함 



### 레드블랙 트리

* 모든 노드를 빨간색이나 검은색으로 색칠하여, 연결된 노드들은 색이 중복되지 않도록 관리함





##💡 짚고 넘어가기



### * 그래프와 트리의 차이점 

> * 그래프는 노드와 노드를 연결하는 간선을 모아놓은 자료구조
> * 트리는 그래프의 일종으로, 순환되지 않는 방향 그래프
> * 그래프는 네트워크 구조를 가져, 부모-자식 노드 간의 개념이 없음
> * 트리는 계층 구조를 가져, 루트 노드를 제외한 자식 노드는 한 개의 부모 노드만 가짐
> * 그래프에서는 노드 간 다양한 경로를 구할 수 있지만, 트리는 하나의 경로만 가짐

### * 레드 블랙 트리의 삽입, 삭제 과정



### * BST와 Binary Tree의 차이점

> * 이진 탐색 트리(`Binary Search Tree`)는 이진 탐색과 연결 리스트를 결합한 자료구조 
> * 



### * Full binary tree(정) / Complete binary tree(완전) / perfect binary tree(포화)의 차이점



### * 이진 탐색 트리(`BST`)의 시간 복잡도



### * BST의 word time complexity? Worst case 는 어떤 경우에 발생하는지?



### * 이진 트리는 어디에 자주 사용되는지?



### * B tree와 B+ tree 의 차이점



### * Binary Search Tree와 Heap 의 차이점



### * 이진 트리를 좌우 반전시키면?



### * DFS와 BFS의 차이점



### * 그래프를 인접리스트나 인접행렬로 구현할 때 차이점, 장단점, 활용



### 



### * tree traversal 4가지 방식



### * 최소 스패닝 트리 (`Minimum Spanning Tree: MST`)란?

> 그래프의 edge weight 값이 최소인 스패닝 트리
>
> 스패닝 트리 : 그래프의 모든 vertex가 cycle 없이 연결된 상태  



### * 최소 스패닝 트리(`MST`)를 구하는 2가지 방식과 차이점

* 크루스칼(`kruskal`) 과 프림(`prim`) 알고리즘으로 만들 수 있음 
* 크루스칼은 가중치를 기준으로 정렬한 후에 MST가 될 때까지 간선을 하나씩 선택 또는 삭제해 나가는 방식. 사이클을 형성하는 간선은 추가하지 않고 간선의 수가 정점의 수보다 하나 작을 때 MST가 완성된다.(그리디 알고리즘)
* 프림은 시작 정점부터 단계적으로 트리를 확장하는 방법



### 크루스칼 알고리즘 작동 방식



### 위상 정렬이란?



### 그래프가 순환하는지 아닌지 판단하는 방법



### 다익스트라 알고리즘의 시간 복잡도, 공간 복잡도 



### 최단 경로를 구하려면?







1. 트리
   - 이진트리
     - 순회 방법
     - binary search tree
       - avl tree
       - 레드-블랙트리
     - full binary tree
     - complete binary tree
   - B tree
     - B+ tree
   - 트라이
2. 그래프
   - 그래프와 트리의 차이점





